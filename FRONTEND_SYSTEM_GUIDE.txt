â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    FINZO - FRONTEND SYSTEM GUIDE                             â•‘
â•‘           Flutter Mobile App - Architecture, State Management, UI              â•‘
â•‘                    For Senior Mobile Developers                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

================================================================================
PROJECT STRUCTURE - FLUTTER APP
================================================================================

Project Path: /mobile

Directory Layout (Clean Architecture):
  mobile/
  â”œâ”€â”€ lib/
  â”‚   â”œâ”€â”€ main.dart ........................ App entry point, MultiProvider setup
  â”‚   â”œâ”€â”€ config/
  â”‚   â”‚   â”œâ”€â”€ app_theme.dart .............. Material Design 3 theme
  â”‚   â”‚   â””â”€â”€ constants.dart .............. App-wide constants
  â”‚   â”œâ”€â”€ providers/ ....................... State management (Provider pattern)
  â”‚   â”‚   â”œâ”€â”€ theme_provider.dart
  â”‚   â”‚   â”œâ”€â”€ auth_provider.dart
  â”‚   â”‚   â”œâ”€â”€ expense_provider.dart
  â”‚   â”‚   â”œâ”€â”€ income_provider.dart
  â”‚   â”‚   â”œâ”€â”€ analytics_provider.dart
  â”‚   â”‚   â”œâ”€â”€ debt_provider.dart
  â”‚   â”‚   â”œâ”€â”€ splitwise_provider.dart
  â”‚   â”‚   â”œâ”€â”€ sms_provider.dart
  â”‚   â”‚   â””â”€â”€ language_provider.dart
  â”‚   â”œâ”€â”€ screens/ ......................... UI Screens
  â”‚   â”‚   â”œâ”€â”€ splash_screen.dart
  â”‚   â”‚   â”œâ”€â”€ auth/
  â”‚   â”‚   â”‚   â”œâ”€â”€ login_screen.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ register_screen.dart
  â”‚   â”‚   â”‚   â””â”€â”€ password_reset_screen.dart
  â”‚   â”‚   â”œâ”€â”€ home/
  â”‚   â”‚   â”‚   â”œâ”€â”€ home_screen.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ expense_list_screen.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ add_expense_screen.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ debt_list_screen.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ analytics_screen.dart
  â”‚   â”‚   â”‚   â””â”€â”€ budget_screen.dart
  â”‚   â”‚   â”œâ”€â”€ splitwise/
  â”‚   â”‚   â”‚   â”œâ”€â”€ splitwise_home_screen.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ create_group_screen.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ group_detail_screen.dart
  â”‚   â”‚   â”‚   â””â”€â”€ settlement_screen.dart
  â”‚   â”‚   â”œâ”€â”€ kyc/
  â”‚   â”‚   â”‚   â”œâ”€â”€ kyc_intro_screen.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ document_upload_screen.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ selfie_screen.dart
  â”‚   â”‚   â”‚   â””â”€â”€ kyc_status_screen.dart
  â”‚   â”‚   â”œâ”€â”€ markets/ ................... (Future: Markets feature)
  â”‚   â”‚   â”œâ”€â”€ feature_selection_screen.dart
  â”‚   â”‚   â””â”€â”€ widgets/
  â”‚   â”‚       â”œâ”€â”€ custom_app_bar.dart
  â”‚   â”‚       â”œâ”€â”€ transaction_card.dart
  â”‚   â”‚       â”œâ”€â”€ category_icon.dart
  â”‚   â”‚       â”œâ”€â”€ bottom_nav_bar.dart
  â”‚   â”‚       â””â”€â”€ loading_shimmer.dart
  â”‚   â”œâ”€â”€ services/ ....................... API & Device services
  â”‚   â”‚   â”œâ”€â”€ api_service.dart ........... REST API client
  â”‚   â”‚   â”œâ”€â”€ auth_service.dart ......... Authentication operations
  â”‚   â”‚   â”œâ”€â”€ expense_service.dart ...... Expense API calls
  â”‚   â”‚   â”œâ”€â”€ sms_service.dart ......... SMS reading (Android)
  â”‚   â”‚   â””â”€â”€ storage_service.dart ..... Secure token storage
  â”‚   â”œâ”€â”€ models/ ......................... Data models
  â”‚   â”‚   â”œâ”€â”€ user.dart
  â”‚   â”‚   â”œâ”€â”€ expense.dart
  â”‚   â”‚   â”œâ”€â”€ income.dart
  â”‚   â”‚   â”œâ”€â”€ group.dart
  â”‚   â”‚   â””â”€â”€ kyc.dart
  â”‚   â”œâ”€â”€ l10n/ .......................... Localization files
  â”‚   â”‚   â”œâ”€â”€ app_localizations.dart
  â”‚   â”‚   â”œâ”€â”€ app_en.dart (English)
  â”‚   â”‚   â”œâ”€â”€ app_hi.dart (Hindi)
  â”‚   â”‚   â””â”€â”€ ... (other languages)
  â”‚   â”œâ”€â”€ features/ ...................... Feature modules
  â”‚   â”‚   â”œâ”€â”€ financial_calculator/
  â”‚   â”‚   â”‚   â”œâ”€â”€ finance_manager_screen.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ sip_calculator.dart
  â”‚   â”‚   â”‚   â”œâ”€â”€ emi_calculator.dart
  â”‚   â”‚   â”‚   â””â”€â”€ tax_calculator.dart
  â”‚   â”‚   â””â”€â”€ (other features)
  â”‚   â””â”€â”€ utils/ ......................... Helper functions
  â”‚       â”œâ”€â”€ date_utils.dart
  â”‚       â”œâ”€â”€ currency_formatter.dart
  â”‚       â””â”€â”€ validators.dart
  â”œâ”€â”€ pubspec.yaml ....................... Dependencies
  â”œâ”€â”€ pubspec.lock ....................... Locked versions
  â”œâ”€â”€ analysis_options.yaml .............. Lint rules
  â””â”€â”€ android/ .......................... Android native code
      â”œâ”€â”€ app/build.gradle
      â””â”€â”€ AndroidManifest.xml (SMS permissions)

================================================================================
APP ENTRY POINT & INITIALIZATION (main.dart)
================================================================================

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Initialize SMS provider early
  final smsProvider = SmsProvider();
  await smsProvider.initializeOnStartup();
  
  runApp(MyApp(smsProvider: smsProvider));
}

Multi-Provider Setup:
  The app uses Provider pattern for state management
  Each feature has its own provider (ChangeNotifier)
  
  Providers:
    1. ThemeProvider - Light/dark mode, Material Design 3 theme
    2. AuthProvider - Login/logout, token management
    3. ExpenseProvider - Expense CRUD, filtering, caching
    4. IncomeProvider - Income tracking
    5. AnalyticsProvider - Charts data, calculations
    6. DebtProvider - Debt tracking
    7. SplitWiseProvider - Group expenses
    8. SmsProvider - SMS auto-parsing
    9. LanguageProvider - Multi-language support

MaterialApp Configuration:
  â€¢ Material Design 3 (latest Flutter design system)
  â€¢ Dynamic theme colors (based on system/user preference)
  â€¢ Localization delegates for multi-language
  â€¢ Navigation: Named routes or Navigator
  â€¢ Home: SplashScreen (checks auth state)

Material Design 3 Integration:
  â€¢ ColorScheme.fromSeed(seedColor)
    â””â”€â†’ Auto-generates 13 color variations from single seed
    â””â”€â†’ Creates harmonious color palette
  â€¢ Dynamic Material You colors (Android 12+)
    â””â”€â†’ Adapts to device wallpaper colors
  â€¢ Smooth transitions & animations
  â€¢ Updated typography scale

================================================================================
STATE MANAGEMENT - PROVIDER PATTERN DEEP DIVE
================================================================================

Architecture: MVVM-like with Providers

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PROVIDER PATTERN FLOW                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User Action (Tap button)
         â†“
    Screen Widget
         â†“
    Calls Provider method (provider.addExpense(data))
         â†“
    Provider calls Service (expenseService.createExpense)
         â†“
    Service makes API call (http.post)
         â†“
    Response received
         â†“
    Provider updates state (notifyListeners())
         â†“
    Consumer/Selector widgets rebuild
         â†“
    UI updates automatically

Key Concepts:

1. ChangeNotifier:
   Base class for all providers
   â””â”€â†’ Holds mutable state
   â””â”€â†’ notifyListeners() triggers rebuild
   â””â”€â†’ Mixing with ChangeNotifier = ChangeNotifierProvider

2. Consumer Widget:
   Listens to provider changes
   â””â”€â†’ Rebuilds when provider notifies
   â””â”€â†’ Syntax: Consumer<ProviderType>(
         builder: (context, provider, child) => Widget
       )

3. Selector Widget:
   More efficient Consumer (rebuilds only if selected data changes)
   â””â”€â†’ Syntax: Selector<ProviderType, SelectedType>(
         selector: (_, provider) => provider.selectedField,
         builder: (context, selectedValue, child) => Widget
       )

4. Provider.of:
   Listen to provider without Consumer
   â””â”€â†’ Syntax: Provider.of<ProviderType>(context).method()
   â””â”€â†’ listen: false to avoid rebuilds

Example Provider (ExpenseProvider):

class ExpenseProvider with ChangeNotifier {
  List<Expense> _expenses = [];
  bool _isLoading = false;
  String? _error;
  
  // Getters
  List<Expense> get expenses => _expenses;
  bool get isLoading => _isLoading;
  String? get error => _error;
  
  // Methods (called from UI)
  Future<void> fetchExpenses() async {
    try {
      _isLoading = true;
      notifyListeners();
      
      // API call
      _expenses = await ExpenseService.getExpenses();
      _error = null;
      
      notifyListeners();
    } catch (e) {
      _error = e.toString();
      notifyListeners();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
  
  Future<void> addExpense(Expense expense) async {
    try {
      _isLoading = true;
      notifyListeners();
      
      // API call
      final created = await ExpenseService.createExpense(expense);
      _expenses.add(created);
      
      notifyListeners();
    } catch (e) {
      _error = e.toString();
      notifyListeners();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
}

Example Usage in Screen:

class ExpenseListScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Expenses')),
      body: Consumer<ExpenseProvider>(
        builder: (context, provider, child) {
          if (provider.isLoading) {
            return LoadingShimmer(); // Custom loading widget
          }
          
          if (provider.error != null) {
            return ErrorWidget(error: provider.error);
          }
          
          return ListView.builder(
            itemCount: provider.expenses.length,
            itemBuilder: (context, index) {
              return ExpenseCard(expense: provider.expenses[index]);
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => Navigator.push(
          context,
          MaterialPageRoute(builder: (_) => AddExpenseScreen()),
        ),
        child: Icon(Icons.add),
      ),
    );
  }
}

AuthProvider Special Pattern:

class AuthProvider with ChangeNotifier {
  User? _user;
  String? _token;
  bool _isLoggedIn = false;
  
  bool get isLoggedIn => _isLoggedIn;
  User? get user => _user;
  
  Future<bool> login(String email, String password) async {
    try {
      final result = await AuthService.login(email, password);
      _token = result['token'];
      _user = User.fromJson(result['user']);
      _isLoggedIn = true;
      
      // Store token securely
      await StorageService.saveToken(_token!);
      
      notifyListeners();
      return true;
    } catch (e) {
      return false;
    }
  }
  
  Future<void> logout() async {
    _user = null;
    _token = null;
    _isLoggedIn = false;
    
    // Clear secure storage
    await StorageService.deleteToken();
    
    notifyListeners();
  }
  
  // Check if logged in on app start
  Future<void> checkAuthStatus() async {
    final token = await StorageService.getToken();
    if (token != null) {
      _token = token;
      _isLoggedIn = true;
    }
    notifyListeners();
  }
}

Performance Tips:

âœ“ Use Selector instead of Consumer when possible
  â””â”€â†’ Reduces unnecessary rebuilds
âœ“ Split providers by feature domain
  â””â”€â†’ Expense, Income, Analytics separate
âœ“ Lazy load expensive operations
  â””â”€â†’ Don't fetch on app start, fetch on screen open
âœ“ Cache data with TTL
  â””â”€â†’ Avoid redundant API calls
âœ“ Use const widgets
  â””â”€â†’ Widgets not depending on data should be const

================================================================================
API INTEGRATION - REST CLIENT
================================================================================

File: services/api_service.dart

The ApiService handles all HTTP communication with backend.

Initialization:

class ApiService {
  static final Dio _dio = Dio(
    BaseOptions(
      baseUrl: 'http://localhost:5001/api',
      connectTimeout: Duration(seconds: 10),
      receiveTimeout: Duration(seconds: 10),
      headers: {
        'Content-Type': 'application/json',
      },
    ),
  );
  
  static void init() {
    // Add interceptors
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
          // Add token to every request
          final token = StorageService.getToken();
          if (token != null) {
            options.headers['Authorization'] = 'Bearer $token';
          }
          return handler.next(options);
        },
        onError: (error, handler) {
          // Handle 401 - redirect to login
          if (error.response?.statusCode == 401) {
            // Clear token and redirect
            StorageService.deleteToken();
            // Navigate to login
          }
          return handler.next(error);
        },
      ),
    );
  }
}

API Methods (Example):

// GET request with parameters
Future<List<Expense>> getExpenses({
  required String startDate,
  required String endDate,
  String? category,
  int? limit,
}) async {
  try {
    final response = await _dio.get(
      '/expenses',
      queryParameters: {
        'startDate': startDate,
        'endDate': endDate,
        if (category != null) 'category': category,
        if (limit != null) 'limit': limit,
      },
    );
    
    if (response.statusCode == 200) {
      final List expenses = response.data['data'];
      return expenses.map((e) => Expense.fromJson(e)).toList();
    } else {
      throw 'Failed to fetch expenses';
    }
  } on DioException catch (e) {
    throw e.message ?? 'Network error';
  }
}

// POST request with body
Future<Expense> createExpense(Expense expense) async {
  try {
    final response = await _dio.post(
      '/expenses',
      data: expense.toJson(),
    );
    
    if (response.statusCode == 201) {
      return Expense.fromJson(response.data['data']);
    } else {
      throw response.data['message'] ?? 'Failed to create expense';
    }
  } on DioException catch (e) {
    throw e.message ?? 'Network error';
  }
}

// File upload with multipart
Future<KycResult> uploadKycDocument({
  required File documentFile,
  required String documentType,
}) async {
  try {
    final formData = FormData.fromMap({
      'file': await MultipartFile.fromFile(
        documentFile.path,
        filename: documentFile.path.split('/').last,
      ),
      'documentType': documentType,
    });
    
    final response = await _dio.post(
      '/kyc/upload-document',
      data: formData,
    );
    
    if (response.statusCode == 200) {
      return KycResult.fromJson(response.data['data']);
    } else {
      throw response.data['message'] ?? 'Upload failed';
    }
  } on DioException catch (e) {
    throw e.message ?? 'Network error';
  }
}

Error Handling Pattern:

try {
  // API call
  final result = await service.method();
  
  // Success - update UI
  provider.updateState(result);
  
} on DioException catch (e) {
  // Network errors
  if (e.type == DioExceptionType.connectionTimeout) {
    showError('Connection timeout - please try again');
  } else if (e.type == DioExceptionType.unknown) {
    showError('Network error - check your connection');
  } else {
    showError(e.message ?? 'Unknown error');
  }
  
} catch (e) {
  // Generic errors
  showError('An error occurred: ${e.toString()}');
}

HTTP Interceptors:

The Dio client automatically:
  âœ“ Adds Authorization: Bearer {token} to every request
  âœ“ Handles 401 Unauthorized (redirects to login)
  âœ“ Handles 5xx Server errors (shows user error)
  âœ“ Logs all requests/responses (development mode)
  âœ“ Retries on network timeout (configurable)
  âœ“ Gzip compression of request/response

Performance:

Connection Pooling:
  â””â”€â†’ Reuses HTTP connections
  â””â”€â†’ Faster subsequent requests
  â””â”€â†’ Automatically managed by Dio

Request Deduplication:
  â””â”€â†’ Don't make same API call twice simultaneously
  â””â”€â†’ Implement caching layer

Timeout Handling:
  â””â”€â†’ 10 second timeout per request
  â””â”€â†’ Shows "network error" to user
  â””â”€â†’ Allows retry

================================================================================
SCREENS & UI COMPONENTS
================================================================================

Screen Types:

1. Authentication Screens
   â€¢ LoginScreen: Email + password login
   â€¢ RegisterScreen: Sign up with validation
   â€¢ PasswordResetScreen: Forgot password flow

2. Home Screens
   â€¢ HomeScreen: Dashboard with expense summary
   â€¢ ExpenseListScreen: All transactions with filters
   â€¢ AddExpenseScreen: Create/edit transaction
   â€¢ AnalyticsScreen: Charts and insights
   â€¢ BudgetScreen: Budget tracking and alerts

3. Group Expense Screens
   â€¢ SplitWiseHomeScreen: List of groups
   â€¢ CreateGroupScreen: Create new group
   â€¢ GroupDetailScreen: Group expenses and balances
   â€¢ SettlementScreen: Pay/settle debts

4. KYC Verification Screens
   â€¢ KycIntroScreen: Explain KYC process
   â€¢ DocumentUploadScreen: Upload ID with camera/gallery
   â€¢ SelfieScreen: Capture selfie for face matching
   â€¢ KycStatusScreen: Check verification status

5. Feature Screens
   â€¢ FeatureSelectionScreen: Choose between features
   â€¢ FinancialCalculatorScreen: SIP, EMI, Tax calculators
   â€¢ MarketsScreen: Placeholder for future feature

Component Library:

Reusable Widgets:

TransactionCard:
  Displays single expense/income in list
  Properties: transaction, onEdit, onDelete
  Shows: Amount, category icon, description, date
  Supports: Swipe actions, long press context menu

CategoryIcon:
  Renders category icon with color
  14 categories with distinct icons
  Maps: 'food' â†’ ğŸ”, 'transport' â†’ ğŸš—, etc.

CustomAppBar:
  Themed app bar with:
  â€¢ Title
  â€¢ Back button
  â€¢ Action buttons (settings, menu)
  â€¢ Profile picture (optional)

BottomNavigationBar:
  Fixed navigation across 5 main tabs:
  â€¢ Home (expenses overview)
  â€¢ Analytics (charts)
  â€¢ Groups (splitwise)
  â€¢ KYC (verification)
  â€¢ Settings (profile, language)

LoadingShimmer:
  Skeleton loading state
  Shows placeholder cards with shimmer animation
  Improves perceived performance

Chart Widgets (fl_chart):

PieChart (Category breakdown):
  â€¢ Each slice = category
  â€¢ Tap to drill down
  â€¢ Legend on side
  â€¢ Animated transitions

LineChart (Trend):
  â€¢ X-axis: dates
  â€¢ Y-axis: amount
  â€¢ Smooth curves
  â€¢ Tooltips on hover
  â€¢ Color gradient under line

BarChart (Monthly comparison):
  â€¢ Two bars: current vs previous month
  â€¢ Color coded
  â€¢ Percentage change indicator

Dialog Widgets:

ConfirmDialog:
  Confirms destructive actions
  "Are you sure you want to delete?"
  Two buttons: Cancel, Confirm

ErrorDialog:
  Shows error messages
  Icon + message + Dismiss button

ProgressDialog:
  Shows during loading
  Circular progress indicator
  "Please wait..." message

================================================================================
DATA MODELS
================================================================================

Models use JSON serialization for API integration.

User Model:
class User {
  final String id;
  final String name;
  final String email;
  final String? profilePicture;
  final double monthlyBudget;
  final int savingsTarget;
  final bool emailVerified;
  final String kycStatus; // NOT_STARTED, PENDING, VERIFIED, FAILED
  final DateTime createdAt;
  
  User.fromJson(Map<String, dynamic> json)
    : id = json['id'],
      name = json['name'],
      // ... etc
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    // ... etc
  };
}

Expense Model:
class Expense {
  final String id;
  final String user;
  final double amount;
  final String category; // 14 categories
  final String description;
  final String? merchant;
  final DateTime date;
  final String source; // 'manual' or 'sms_auto'
  final String? smsId;
  final double? confidence; // for SMS-parsed items
  final DateTime createdAt;
  
  // Getters for UI
  String get categoryLabel => CategoryHelper.getLabel(category);
  IconData get categoryIcon => CategoryHelper.getIcon(category);
  Color get categoryColor => CategoryHelper.getColor(category);
  
  String get formattedDate {
    return DateFormat('dd MMM yyyy').format(date);
  }
  
  String get formattedAmount {
    return CurrencyFormatter.format(amount);
  }
}

Income Model:
class Income {
  final String id;
  final String user;
  final double amount;
  final String source; // pocket_money, salary, freelance, gift, scholarship, other
  final String description;
  final int month;
  final int year;
  final DateTime date;
  final DateTime createdAt;
}

Group Model:
class Group {
  final String id;
  final String name;
  final String description;
  final List<GroupMember> members;
  final String inviteCode;
  final String createdBy;
  final DateTime createdAt;
  
  double getBalance(String userId) {
    // Calculate balance for user in group
  }
  
  Map<String, double> getAllBalances() {
    // Get all user balances
  }
}

KYC Model:
class KycDocument {
  final String id;
  final String user;
  final String documentType; // aadhaar, pan, passport, driving_license
  final String documentImage;
  final OcrData ocrData;
  final String? selfieImage;
  final double? faceMatchScore;
  final List<VerificationStep> verificationHistory;
}

================================================================================
SMS INTEGRATION (Android-specific)
================================================================================

File: services/sms_service.dart & providers/sms_provider.dart

Android Permissions (AndroidManifest.xml):
<uses-permission android:name="android.permission.READ_SMS" />
<uses-permission android:name="android.permission.RECEIVE_SMS" />

Permission Handling (Flutter):
class SmsProvider with ChangeNotifier {
  Future<void> initializeOnStartup() async {
    final status = await Permission.sms.request();
    
    if (status.isGranted) {
      // Permission granted, listen to SMS
      listenToSms();
    } else if (status.isDenied) {
      // Ask later
      print('SMS permission denied');
    } else if (status.isDenied) {
      // Need to go to settings
      openAppSettings();
    }
  }
}

Reading SMS (Flutter plugin):
The app uses a custom SMS reading mechanism:

Future<List<SmsMessage>> fetchSmsMessages() async {
  // Read SMS using platform channel or package
  // Filter for bank/payment app senders
  // Return list of SMS
}

Parsing Flow:

1. Background Service (if available):
   â€¢ Listens for incoming SMS in background
   â€¢ Filters bank SMS
   â€¢ Queues for processing

2. Foreground Parsing:
   â€¢ User taps "Sync SMS"
   â€¢ Fetches recent SMS messages
   â€¢ Sends to backend for Gemini parsing
   â€¢ Shows parsed transactions
   â€¢ User can confirm/reject

3. Auto-Confirmation:
   â€¢ If confidence > 0.85: Auto-save
   â€¢ If confidence 0.70-0.85: Show review dialog
   â€¢ If confidence < 0.70: Reject

Data Structures:

ParsedTransaction {
  type: 'expense' | 'income',
  amount: double,
  merchant: string,
  category: string,
  confidence: double (0-1),
  rawSms: string,
  status: 'pending' | 'confirmed' | 'rejected'
}

UI Flow:

SMS Settings Screen:
  â€¢ Enable/disable SMS parsing
  â€¢ Show last sync time
  â€¢ Manual sync button
  â€¢ Sync history log

SMS List Screen:
  â€¢ Shows unparsed transactions
  â€¢ Group by date
  â€¢ Each transaction:
    - Parsed details
    - Confidence score
    - Confirm/Edit/Reject buttons
  â€¢ Batch operations (confirm all)

================================================================================
FINANCIAL CALCULATORS (Feature Module)
================================================================================

File: features/financial_calculator/finance_manager_screen.dart

9 Built-in Calculators:

1. SIP Calculator (Systematic Investment Plan)
   Inputs: Monthly investment, Annual return %, Years
   Calculates: Future value, total return
   Use: Plan mutual fund investments

2. EMI Calculator (Equated Monthly Installment)
   Inputs: Loan amount, Interest rate %, Tenure
   Calculates: Monthly EMI, Total interest, Total amount
   Use: Home/car loan planning

3. Compound Interest Calculator
   Inputs: Principal, Rate, Time
   Calculates: Final amount, Interest earned
   Use: Savings goal planning

4. Inflation Calculator
   Inputs: Current amount, Inflation rate, Years
   Calculates: Purchasing power
   Use: Understand real vs nominal value

5. Retirement Calculator
   Inputs: Current savings, Monthly contribution, Returns, Years to retirement
   Calculates: Retirement corpus needed
   Use: Retirement planning

6. Net Present Value (NPV)
   Inputs: Cash flows, Discount rate
   Calculates: Project viability
   Use: Investment decision making

7. Tax Calculator
   Inputs: Income, Deductions, Tax regime
   Calculates: Tax liability, effective rate
   Use: Tax optimization

8. Break-even Analysis
   Inputs: Fixed costs, Variable costs, Selling price
   Calculates: Break-even point
   Use: Business planning

9. Loan Comparison
   Inputs: Multiple loans with different terms
   Compares: EMI, total cost, best option
   Use: Choose best loan

Implementation Pattern:

class SipCalculator {
  double calculateFutureValue({
    required double monthlyAmount,
    required double annualRate,
    required int years,
  }) {
    double monthlyRate = annualRate / 12 / 100;
    int months = years * 12;
    
    // Formula: FV = P Ã— (((1 + r)^n - 1) / r)
    double futureValue = monthlyAmount *
        (((pow(1 + monthlyRate, months) - 1) / monthlyRate));
    
    return futureValue;
  }
}

UI:

Single screen with Tab view:
  â€¢ Tab 1: SIP Calculator
  â€¢ Tab 2: EMI Calculator
  â€¢ Tab 3: Tax Calculator
  â€¢ ... etc

Each tab contains:
  â€¢ Input fields with validation
  â€¢ Calculate button
  â€¢ Result display card
  â€¢ Share/Save result option

Results are exportable as PDF or image.

================================================================================
THEMING & MATERIAL DESIGN 3
================================================================================

File: config/app_theme.dart

Color System (Material 3):

seedColor: Color(0xFF2E7D32) // Green (Finzo brand)

Auto-generated Colors:
  â€¢ Primary: Main brand color
  â€¢ Secondary: Complementary color
  â€¢ Tertiary: Accent color
  â€¢ Neutral: Gray scales
  â€¢ Error: Red for errors
  â€¢ Surface: Background colors
  â€¢ Outline: Borders and dividers

Each color has light/dark variants (tonal).

Theme Definition:

ThemeData lightTheme = ThemeData(
  useMaterial3: true,
  colorScheme: ColorScheme.fromSeed(
    seedColor: Color(0xFF2E7D32),
    brightness: Brightness.light,
  ),
  typography: Typography.material2021(),
  
  // Component customization
  appBarTheme: AppBarTheme(
    backgroundColor: seedColor,
    elevation: 0,
    foregroundColor: Colors.white,
  ),
  
  cardTheme: CardTheme(
    elevation: 2,
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(12),
    ),
  ),
  
  elevatedButtonTheme: ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      padding: EdgeInsets.symmetric(horizontal: 32, vertical: 16),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
    ),
  ),
);

Dark Theme:
Same structure but with brightness: Brightness.dark
Darker surface colors, lighter text.

Theme Provider:

class ThemeProvider with ChangeNotifier {
  bool _isDarkMode = false;
  
  bool get isDarkMode => _isDarkMode;
  
  ThemeData get currentTheme {
    return _isDarkMode ? darkTheme : lightTheme;
  }
  
  void toggleTheme() {
    _isDarkMode = !_isDarkMode;
    // Persist to shared preferences
    notifyListeners();
  }
}

Dynamic Material You (Android 12+):

When running on Android 12+:
  â€¢ extracts dominant colors from wallpaper
  â€¢ Creates theme with device colors
  â€¢ Theme updates when wallpaper changes
  â€¢ Seamless integration with system UI

Accessibility:

  âœ“ Proper contrast ratios (WCAG AA)
  âœ“ Large touch targets (48dp minimum)
  âœ“ Semantic labels for screen readers
  âœ“ High contrast mode support
  âœ“ Text scaling support

Typography (Material Typography Scale):

Display Large: 57sp, weight: 400
Display Medium: 45sp
Display Small: 36sp
Headline Large: 32sp
Headline Medium: 28sp
...
Body Large: 16sp
Body Medium: 14sp
Body Small: 12sp
Label Large: 14sp
Label Medium: 12sp

Consistent across light/dark themes.

================================================================================
LOCALIZATION - MULTI-LANGUAGE SUPPORT
================================================================================

File: l10n/app_localizations.dart

Supported Languages:
  â€¢ English (en)
  â€¢ Hindi (hi)
  â€¢ Tamil (ta)
  â€¢ Kannada (kn)
  â€¢ Malayalam (ml)
  â€¢ Telugu (te)

Implementation:

class AppLocalizations {
  static const Map<String, Map<String, String>> _localizations = {
    'en': {
      'app_title': 'Finzo',
      'login': 'Login',
      'logout': 'Logout',
      'expense': 'Expense',
      'expenses': 'Expenses',
      'income': 'Income',
      'category': 'Category',
      'amount': 'Amount',
      'date': 'Date',
      'description': 'Description',
      'add_expense': 'Add Expense',
      'add_income': 'Add Income',
      'total_expense': 'Total Expense',
      'total_income': 'Total Income',
      'balance': 'Balance',
      'calculator': 'Calculator',
      'sip_calculator': 'SIP Calculator',
      'emi_calculator': 'EMI Calculator',
      'groups': 'Groups',
      'split_bill': 'Split Bill',
      'create_group': 'Create Group',
      'join_group': 'Join Group',
      'invite_code': 'Invite Code',
      'kyc': 'KYC Verification',
      'upload_document': 'Upload Document',
      'upload_selfie': 'Upload Selfie',
      'verify_email': 'Verify Email',
      'settings': 'Settings',
      'language': 'Language',
      'theme': 'Theme',
      'dark_mode': 'Dark Mode',
      'light_mode': 'Light Mode',
      'notifications': 'Notifications',
      'about': 'About',
      'help': 'Help',
      'contact_us': 'Contact Us',
      'error': 'Error',
      'success': 'Success',
      'loading': 'Loading...',
      'retry': 'Retry',
      'cancel': 'Cancel',
      'save': 'Save',
      'delete': 'Delete',
      'edit': 'Edit',
      'close': 'Close',
    },
    'hi': {
      'app_title': 'à¤«à¤¿à¤¨à¤œà¤¼à¥‹',
      'login': 'à¤²à¥‰à¤— à¤‡à¤¨ à¤•à¤°à¥‡à¤‚',
      'logout': 'à¤²à¥‰à¤— à¤†à¤‰à¤Ÿ à¤•à¤°à¥‡à¤‚',
      'expense': 'à¤–à¤°à¥à¤š',
      'expenses': 'à¤–à¤°à¥à¤š',
      // ... hindi translations
    },
    'ta': {
      'app_title': 'à®ƒà®ªà®¿à®©à¯à®šà¯‹',
      'login': 'à®‰à®³à¯à®¨à¯à®´à¯ˆà®•',
      'logout': 'à®µà¯†à®³à®¿à®¯à¯‡à®±à¯à®•',
      // ... tamil translations
    },
    // ... other languages
  };
  
  static String get(String key, String locale) {
    return _localizations[locale]?[key] ?? 
           _localizations['en']?[key] ?? 
           key;
  }
}

Usage in UI:

Text(AppLocalizations.get('app_title', locale))

Provider:

class LanguageProvider with ChangeNotifier {
  String _locale = 'en';
  
  String get locale => _locale;
  
  Future<void> setLocale(String newLocale) async {
    _locale = newLocale;
    
    // Persist to storage
    await SharedPreferences.getInstance().then((prefs) {
      prefs.setString('locale', newLocale);
    });
    
    notifyListeners();
  }
  
  Future<void> load() async {
    final prefs = await SharedPreferences.getInstance();
    _locale = prefs.getString('locale') ?? 'en';
    notifyListeners();
  }
}

On-Device Translation (Advanced):

Uses google_mlkit_translation for:
  â€¢ Real-time translation
  â€¢ No internet required
  â€¢ Automatic detection of input language
  â€¢ Document translation

Localization Best Practices:

  âœ“ All UI text in AppLocalizations
  âœ“ Never hardcode strings in widgets
  âœ“ Date/number formatting respects locale
  âœ“ RTL support for Arabic (future feature)
  âœ“ Pluralization support
  âœ“ Gender agreement in translations

================================================================================
STORAGE - SECURE & LOCAL
================================================================================

Secure Token Storage:

class StorageService {
  static final _secureStorage = FlutterSecureStorage();
  
  static Future<void> saveToken(String token) async {
    await _secureStorage.write(
      key: 'auth_token',
      value: token,
    );
  }
  
  static Future<String?> getToken() async {
    return await _secureStorage.read(key: 'auth_token');
  }
  
  static Future<void> deleteToken() async {
    await _secureStorage.delete(key: 'auth_token');
  }
}

Why Secure Storage?

Plain SharedPreferences:
  âŒ Not encrypted
  âŒ Accessible to other apps
  âŒ Insecure for sensitive data

FlutterSecureStorage:
  âœ“ Encrypted at rest
  âœ“ Platform-specific encryption
    â€¢ Android: KeyStore
    â€¢ iOS: Keychain
  âœ“ Not accessible to other apps
  âœ“ Safe for tokens, passwords, PII

Local Cache (SharedPreferences):

class CacheService {
  static final _prefs = SharedPreferences.getInstance();
  
  static Future<void> setCategoryList(List<String> categories) async {
    final prefs = await _prefs;
    prefs.setStringList('categories', categories);
  }
  
  static Future<List<String>> getCategoryList() async {
    final prefs = await _prefs;
    return prefs.getStringList('categories') ?? [];
  }
}

Cache TTL:

Implement simple TTL:

class CacheEntry<T> {
  final T data;
  final DateTime timestamp;
  final Duration ttl;
  
  bool get isExpired {
    return DateTime.now().difference(timestamp) > ttl;
  }
}

================================================================================
NAVIGATION
================================================================================

Navigation Approaches:

1. Named Routes:
   MaterialApp(
     routes: {
       '/': (context) => SplashScreen(),
       '/login': (context) => LoginScreen(),
       '/home': (context) => HomeScreen(),
       '/expenses': (context) => ExpenseListScreen(),
     },
   )
   
   Usage:
   Navigator.pushNamed(context, '/expenses');

2. Direct Navigation:
   Navigator.push(
     context,
     MaterialPageRoute(
       builder: (context) => ExpenseListScreen(),
     ),
   );

3. Cupertino Navigation (iOS-style):
   CupertinoPageRoute for iOS feel

Navigation with Arguments:

Navigator.pushNamed(
  context,
  '/expense-detail',
  arguments: {'expenseId': 'exp123'},
);

// In destination screen:
@override
Widget build(BuildContext context) {
  final args = ModalRoute.of(context)?.settings.arguments as Map;
  final expenseId = args['expenseId'];
}

Deep Linking (Advanced):

Define route patterns for deep links:
'/expenses/:id' â†’ ExpenseDetailScreen(id)
'/groups/:code/join' â†’ JoinGroupScreen(code)

Handles coming from notifications or external links.

================================================================================
PERFORMANCE OPTIMIZATION
================================================================================

Build Optimization:

const widgets:
  // Avoid rebuilds for static widgets
  class MyStatelessWidget extends StatelessWidget {
    const MyStatelessWidget({Key? key}) : super(key: key);
  }

Repaint Boundary:
  â€¢ Isolate expensive widgets
  â€¢ Reduces rebuild scope
  
  RepaintBoundary(
    child: ExpensiveChart(),
  )

Lazy Loading:

  ListView.builder instead of ListView
  â””â”€â†’ Only builds visible items
  â””â”€â†’ Recycles offscreen items

  PageView.builder for screens
  â””â”€â†’ Load screens on demand

Image Optimization:

  â€¢ Resize images on backend
  â€¢ Use cached_network_image
  â€¢ Compress before upload
  â€¢ Serve from CDN

Memory Management:

  â€¢ Dispose resources in dispose()
  â€¢ Clear large lists when done
  â€¢ Use image.clear() for images
  â€¢ Unsubscribe from streams

Animations:

  â€¢ Use AnimatedBuilder for smooth
  â€¢ Avoid blocking main thread
  â€¢ Use vsync for proper frame timing
  â€¢ Keep animations 60fps

Testing:

Unit Tests:
  â€¢ Models: serialization, formatting
  â€¢ Providers: state changes
  â€¢ Services: API mocking

Widget Tests:
  â€¢ Individual widgets
  â€¢ Interactions (tap, scroll)
  â€¢ State changes

Integration Tests:
  â€¢ Full user flows
  â€¢ Multiple screens
  â€¢ Navigation

================================================================================
DEPLOYMENT CHECKLIST
================================================================================

Pre-submission:

iOS:
  âœ“ Update version in pubspec.yaml
  âœ“ Update build number
  âœ“ Update app icon & splash
  âœ“ Configure signing certificate
  âœ“ Test on iOS 15+
  âœ“ Verify permissions in Info.plist
  âœ“ Check for any hardcoded IPs (use env vars)

Android:
  âœ“ Update version in pubspec.yaml
  âœ“ Update versionCode
  âœ“ Configure keystore for signing
  âœ“ Update app icon & splash
  âœ“ Test on Android 8+ (API 26+)
  âœ“ Check permissions in AndroidManifest.xml
  âœ“ Verify Firebase config (google-services.json)

Common:
  âœ“ Remove debug print statements
  âœ“ Remove log statements
  âœ“ Test on real devices
  âœ“ Verify API endpoint is production
  âœ“ Check dark mode compatibility
  âœ“ Test landscape mode
  âœ“ Remove unused packages
  âœ“ Run analyzer: flutter analyze
  âœ“ Format code: dart format
  âœ“ Test all flows end-to-end

App Store Submission:

iOS:
  â€¢ Sign in with Apple requirement (if using Google)
  â€¢ Privacy policy URL required
  â€¢ App description & keywords
  â€¢ Screenshots (6 languages)
  â€¢ Review guidelines compliance
  â€¢ Contact info & support email

Google Play:

  â€¢ App description (80 characters max)
  â€¢ Full description (4000 chars max)
  â€¢ Short description (80 chars)
  â€¢ Screenshots (minimum 2, up to 8)
  â€¢ Feature graphic
  â€¢ App icon & promo graphic
  â€¢ Category & content rating
  â€¢ Content rating questionnaire
  â€¢ Privacy policy link
  â€¢ Support email

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
End of Frontend System Guide
For more details, refer to Flutter documentation and code comments
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
