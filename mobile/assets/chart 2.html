<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>TradingView</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        #chart {
            width: 100vw;
            height: 100vh;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -18px;
            margin-left: -18px;
            display: none;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="chart"></div>
    <div id="spinner" class="spinner"></div>
    <div id="status"
        style="position: absolute; top: 10px; left: 10px; font-size: 10px; color: rgba(0, 255, 0, 0.4); font-family: monospace; z-index: 1000; pointer-events: none; background: rgba(0,0,0,0.3); padding: 2px 5px; border-radius: 4px;">
        Initializing...</div>
    <div id="error"
        style="position: absolute; top: 40px; left: 10px; right: 10px; color: #ff5555; background: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px; display: none; z-index: 1001; text-align: left; font-family: monospace; border: 1px solid #ff5555; white-space: pre-wrap; word-break: break-all;">
    </div>

    <script>
        const statusEl = document.getElementById('status');
        const errorEl = document.getElementById('error');
        let eventSource = null;

        function setStatus(msg) { statusEl.innerText = msg; console.log(msg); }
        function setError(msg) {
            if (msg) {
                errorEl.innerText = msg;
                errorEl.style.display = 'block';
                console.error(msg);
            } else {
                errorEl.style.display = 'none';
            }
        }

        if (typeof LightweightCharts === 'undefined') {
            setError('Critical: TradingView Library not loaded. Check connection.');
        }

        const params = new URLSearchParams(window.location.search);
        let symbol = params.get('symbol') || 'RELIANCE.NS';
        let symbolsText = params.get('symbols') || ''; // Comma separated for comparison
        let interval = params.get('interval') || '1D';
        let theme = params.get('theme') || 'dark';
        let chartType = params.get('type') || 'candlestick'; // 'candlestick', 'area', 'volume'
        let API_BASE_URL = params.get('baseUrl') || 'http://localhost:5001/api/markets';

        const isComparison = symbolsText.length > 0;
        const symbols = isComparison ? symbolsText.split(',') : [symbol];

        if (API_BASE_URL && !API_BASE_URL.startsWith('http')) {
            API_BASE_URL = 'http://' + API_BASE_URL;
        }

        // Color palette for comparison
        const colors = ['#6366F1', '#F59E0B', '#EF4444', '#10B981', '#EC4899'];

        // Chart Setup
        const chart = LightweightCharts.createChart(document.getElementById('chart'), {
            layout: {
                background: { color: theme === 'dark' ? '#000000' : '#ffffff' },
                textColor: theme === 'dark' ? '#d1d5db' : '#333333',
            },
            grid: {
                vertLines: { color: theme === 'dark' ? '#1f2937' : '#f3f4f6' },
                horzLines: { color: theme === 'dark' ? '#1f2937' : '#f3f4f6' },
            },
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
            rightPriceScale: {
                borderColor: theme === 'dark' ? '#374151' : '#e5e7eb',
                visible: chartType !== 'volume',
                autoScale: true,
            },
            timeScale: { borderColor: theme === 'dark' ? '#374151' : '#e5e7eb', timeVisible: true },
            localization: {
                priceFormatter: (p) => isComparison ? p.toFixed(2) + '%' : p.toFixed(2),
            }
        });

        // Add Legend for Comparison
        const legend = document.createElement('div');
        legend.style.position = 'absolute';
        legend.style.top = '10px';
        legend.style.right = '10px';
        legend.style.zIndex = '10';
        legend.style.display = isComparison ? 'flex' : 'none';
        legend.style.flexDirection = 'column';
        legend.style.gap = '4px';
        legend.style.background = 'rgba(0,0,0,0.5)';
        legend.style.padding = '8px';
        legend.style.borderRadius = '8px';
        legend.style.fontSize = '12px';
        document.body.appendChild(legend);

        let seriesMap = new Map(); // For comparison mode: symbol -> series object
        let mainSeries = null;
        let volumeSeries = null;

        if (isComparison) {
            symbols.forEach((s, idx) => {
                const sObj = chart.addLineSeries({
                    color: colors[idx % colors.length],
                    lineWidth: 2,
                    title: s,
                });
                seriesMap.set(s, sObj);

                // Add tag to legend
                const tag = document.createElement('div');
                tag.style.display = 'flex';
                tag.style.alignItems = 'center';
                tag.style.gap = '8px';
                tag.innerHTML = `<span style="width:10px; height:10px; background:${colors[idx % colors.length]}; border-radius:50%"></span><span style="color:white">${s}</span>`;
                legend.appendChild(tag);
            });
        } else if (chartType === 'area') {
            mainSeries = chart.addAreaSeries({
                lineColor: '#26a69a',
                topColor: 'rgba(38, 166, 154, 0.4)',
                bottomColor: 'rgba(38, 166, 154, 0.0)',
                lineWidth: 2,
            });
        } else if (chartType === 'volume') {
            mainSeries = chart.addHistogramSeries({
                color: '#26a69a',
                priceFormat: { type: 'volume' },
            });
        } else {
            // Default to Candlestick
            mainSeries = chart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
            });
            // Add volume overlay for candlestick mode
            volumeSeries = chart.addHistogramSeries({
                color: '#26a69a',
                priceFormat: { type: 'volume' },
                priceScaleId: '',
            });
            volumeSeries.priceScale().applyOptions({
                scaleMargins: { top: 0.8, bottom: 0 },
            });
        }

        window.onresize = () => chart.applyOptions({ width: window.innerWidth, height: window.innerHeight });

        let streams = [];
        let initialPrices = new Map(); // symbol -> first close price for normalization

        function stopStream() {
            streams.forEach(s => s.close());
            streams = [];
            setStatus('Stream Stopped');
        }

        function startStream() {
            stopStream();
            symbols.forEach(s => {
                const streamUrl = `${API_BASE_URL}/chart/stream?symbol=${encodeURIComponent(s)}&resolution=${interval}`;
                const es = new EventSource(streamUrl);

                es.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.bar) {
                            const bar = data.bar;
                            const series = seriesMap.get(s);
                            const initPrice = initialPrices.get(s);

                            if (series && initPrice) {
                                // Normalize for comparison mode
                                const normalizedValue = ((bar.close - initPrice) / initPrice) * 100;
                                series.update({
                                    time: bar.time,
                                    value: normalizedValue
                                });
                            } else if (!isComparison) {
                                // Original single chart logic
                                if (chartType === 'volume') {
                                    mainSeries.update({
                                        time: bar.time,
                                        value: bar.volume,
                                        color: bar.close >= bar.open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                                    });
                                } else if (chartType === 'area') {
                                    mainSeries.update({
                                        time: bar.time,
                                        value: bar.close
                                    });
                                } else {
                                    mainSeries.update(bar);
                                    if (volumeSeries) {
                                        volumeSeries.update({
                                            time: bar.time,
                                            value: bar.volume,
                                            color: bar.close >= bar.open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                                        });
                                    }
                                }
                                setStatus(`Live: ${bar.close.toFixed(2)}`);
                            }
                        }
                    } catch (e) {
                        console.error('SSE Error', e);
                    }
                };
                streams.push(es);
            });
            if (isComparison) setStatus(`Comparing ${symbols.length} stocks...`);
        }

        async function loadData() {
            document.getElementById('spinner').style.display = 'block';
            setError(null);
            initialPrices.clear();

            try {
                const now = Math.floor(Date.now() / 1000);
                let secondsBack = 30 * 24 * 3600; // Default: 30 days
                const intStr = String(interval).toUpperCase();

                if (intStr === '1D' || intStr === 'D') secondsBack = 90 * 24 * 3600;
                else if (intStr === '1W' || intStr === 'W') secondsBack = 365 * 24 * 3600;
                else if (intStr === '1M' || intStr === 'M') secondsBack = 365 * 24 * 3600;
                else if (intStr === '3M') secondsBack = 365 * 2 * 24 * 3600;
                else if (['1', '5', '15', '30', '60'].includes(intStr)) secondsBack = 7 * 24 * 3600;
                else if (intStr.includes('M') || intStr.includes('Y')) secondsBack = 365 * 2 * 24 * 3600;

                const from = now - secondsBack;

                // Load each symbol
                const loadPromises = symbols.map(async (s) => {
                    const url = `${API_BASE_URL}/chart/bars?symbol=${encodeURIComponent(s)}&resolution=${interval}&from=${from}&to=${now}`;
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(`Fetch fail for ${s}`);
                    const json = await res.json();
                    if (!json.success || !json.data.length) return;

                    const bars = json.data;
                    const firstClose = bars[0].close;
                    initialPrices.set(s, firstClose);

                    if (isComparison) {
                        const series = seriesMap.get(s);
                        if (series) {
                            series.setData(bars.map(b => ({
                                time: b.time,
                                value: ((b.close - firstClose) / firstClose) * 100
                            })));
                        }
                    } else {
                        // Single mode logic
                        if (chartType === 'volume') {
                            mainSeries.setData(bars.map(b => ({
                                time: b.time,
                                value: b.volume,
                                color: (b.close >= b.open) ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                            })));
                        } else if (chartType === 'area') {
                            mainSeries.setData(bars.map(b => ({
                                time: b.time,
                                value: b.close
                            })));
                        } else {
                            mainSeries.setData(bars);
                            if (volumeSeries) {
                                volumeSeries.setData(bars.map(b => ({
                                    time: b.time,
                                    value: b.volume,
                                    color: (b.close >= b.open) ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                                })));
                            }
                        }
                    }
                });

                await Promise.all(loadPromises);
                chart.timeScale().fitContent();
                setStatus(isComparison ? 'Comparison Ready' : `Ready: ${symbol}`);
                startStream();

            } catch (e) {
                setError(`Ready Error: ${e.message}`);
            }
            document.getElementById('spinner').style.display = 'none';
        }

        window.updateConfig = (newSymbol, newInterval, newTheme, newBaseUrl) => {
            stopStream();
            if (newSymbol) symbol = newSymbol;
            if (newInterval) interval = newInterval;
            if (newBaseUrl) API_BASE_URL = newBaseUrl;
            if (newTheme) {
                theme = newTheme;
                chart.applyOptions({
                    layout: {
                        background: { color: theme === 'dark' ? '#000000' : '#ffffff' },
                        textColor: theme === 'dark' ? '#d1d5db' : '#333333',
                    },
                    grid: {
                        vertLines: { color: theme === 'dark' ? '#1f2937' : '#f3f4f6' },
                        horzLines: { color: theme === 'dark' ? '#1f2937' : '#f3f4f6' },
                    },
                });
            }
            loadData();
        }

        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'updateConfig') {
                const { symbol, interval, theme, baseUrl } = event.data;
                window.updateConfig(symbol, interval, theme, baseUrl);
            }
        });

        loadData();
    </script>
</body>

</html>