â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    FINZO - BACKEND SYSTEM GUIDE                              â•‘
â•‘            Node.js API Server, Database Models, and Services                  â•‘
â•‘                    For Senior Backend Engineers                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

================================================================================
BACKEND SERVER STRUCTURE (Node.js + Express)
================================================================================

Project Root: /backend

Directory Layout:
  backend/
  â”œâ”€â”€ src/
  â”‚   â”œâ”€â”€ server.js ........................ Express app initialization
  â”‚   â”œâ”€â”€ config/
  â”‚   â”‚   â”œâ”€â”€ firebase.js ................. Firebase Admin SDK setup
  â”‚   â”‚   â””â”€â”€ database.js ................. Database connection
  â”‚   â”œâ”€â”€ controllers/ ..................... Business logic handlers
  â”‚   â”œâ”€â”€ models/ .......................... Data layer (CRUD ops)
  â”‚   â”œâ”€â”€ routes/ .......................... Express route handlers
  â”‚   â”œâ”€â”€ middleware/ ...................... Authentication, validation
  â”‚   â”œâ”€â”€ services/ ........................ External service integrations
  â”‚   â””â”€â”€ utils/ ........................... Helper functions
  â”œâ”€â”€ uploads/ ............................ File storage (KYC documents)
  â”œâ”€â”€ .env ................................ Environment variables
  â”œâ”€â”€ package.json ......................... Dependencies
  â”œâ”€â”€ startup-check.js .................... Pre-flight checks
  â””â”€â”€ README.md ........................... Documentation

================================================================================
SERVER INITIALIZATION (server.js)
================================================================================

Middleware Stack (Order Matters):

1. Environment Loading:
   require('dotenv').config();
   â””â”€â†’ Loads .env file into process.env

2. Firebase Initialization:
   initializeFirebase()
   â””â”€â†’ Connects to Google Cloud Firestore
   â””â”€â†’ Initializes Firebase Admin SDK
   â””â”€â†’ Non-blocking: If fails, logs warning and continues with MongoDB

3. Express App Creation:
   const app = express();
   app.set('etag', false);
   â””â”€â†’ Disables HTTP 304 Not Modified responses (Flutter compatibility)

4. CORS Middleware:
   app.use(cors({
     origin: '*',
     credentials: true,
     methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
     allowedHeaders: ['Content-Type', 'Authorization']
   }));
   â””â”€â†’ Allows cross-origin requests from mobile/web frontend
   â””â”€â†’ Credentials enabled for cookies (if used)

5. Body Parser Middleware:
   app.use(express.json({ limit: '50mb' }));
   app.use(express.urlencoded({ limit: '50mb', extended: true }));
   â””â”€â†’ Handles JSON and form-encoded requests
   â””â”€â†’ 50MB limit for large file uploads (KYC documents)

6. Request Logging:
   app.use(morgan('dev'));
   â””â”€â†’ Logs every HTTP request: [method] [path] [status] [ms]
   â””â”€â†’ Development format: includes colors and response time

7. Static File Serving:
   app.use('/uploads', express.static('uploads'));
   â””â”€â†’ Serves uploaded KYC documents, selfies
   â””â”€â†’ Accessible at http://localhost:5001/uploads/filename

8. Cache Control Middleware:
   app.use((req, res, next) => {
     res.set('Cache-Control', 'no-store, no-cache, must-revalidate, private');
     delete req.headers['if-none-match'];
     delete req.headers['if-modified-since'];
     next();
   });
   â””â”€â†’ Forces fresh responses (prevents 304 caching issues)
   â””â”€â†’ Critical for Flutter HTTP client compatibility

9. Route Mounting:
   Routes mounted with /api/ prefix:
   â””â”€â†’ /api/auth
   â””â”€â†’ /api/expenses
   â””â”€â†’ /api/income
   â””â”€â†’ /api/analytics
   â””â”€â†’ /api/categories
   â””â”€â†’ /api/groups
   â””â”€â†’ /api/debts
   â””â”€â†’ /api/bill
   â””â”€â†’ /api/sms
   â””â”€â†’ /api/kyc
   â””â”€â†’ /api/statement
   â””â”€â†’ /api/tax

Server Start:
  PORT = process.env.PORT || 5001
  app.listen(PORT, () => console.log(`Server running on port ${PORT}`))

================================================================================
AUTHENTICATION FLOW (Middleware + Controllers)
================================================================================

File: middleware/auth.js

exports.protect = async (req, res, next) => {
  // 1. Extract token from request
  let token;
  
  if (req.headers.authorization?.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  } else if (req.headers['x-auth-token']) {
    token = req.headers['x-auth-token'];  // Fallback header
  }
  
  if (!token) {
    return res.status(401).json({
      success: false,
      message: 'Not authorized - No token provided',
      hint: 'Please include Authorization header with Bearer token'
    });
  }
  
  try {
    // 2. Verify JWT signature & expiration
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // 3. Lookup user in database
    req.user = await User.findById(decoded.id);
    
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'User not found - Token may be invalid'
      });
    }
    
    // 4. Attach user to request, allow next middleware
    next();
    
  } catch (error) {
    return res.status(401).json({
      success: false,
      message: 'Not authorized - Invalid token',
      error: error.message
    });
  }
};

Usage in Routes:
  router.get('/profile', protect, getProfile);
  router.post('/expenses', protect, createExpense);
  â””â”€â†’ Any route with "protect" middleware requires valid token

Token Structure (JWT Payload):
  {
    id: "user_id_from_firestore",
    iat: 1704067200,        // Issued at timestamp
    exp: 1704153600         // Expiration timestamp (7 days later)
  }

Login Flow (authController.js):
  1. User POSTs /api/auth/login with { email, password }
  2. Find user by email: User.findByEmail(email, true)
     â””â”€â†’ true = include password hash in result
  3. Compare submitted password with hash: bcrypt.compare()
  4. If match: Generate JWT token = jwt.sign({ id }, JWT_SECRET, { expiresIn: '7d' })
  5. Return token to frontend
  6. Frontend stores in secure storage
  7. Frontend includes in every API request: Authorization: Bearer {token}

Performance Optimization (Current):
  âœ“ JWT verification is local (no DB lookup)
  âœ“ User lookup done once per request
  âœ“ Bcrypt comparison optimized (8 rounds, not 10)
  âœ“ Token expiration prevents long-lived credentials

================================================================================
MODEL LAYER - DATA PERSISTENCE PATTERNS
================================================================================

All models follow this pattern:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GENERIC CRUD PATTERN                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

// Create
const create = async (data) => {
  const db = getDb();  // Get Firestore instance
  const docRef = await db.collection(COLLECTION_NAME).add(data);
  return { id: docRef.id, ...data };  // Return with generated ID
};

// Read - Find by ID
const findById = async (id) => {
  const db = getDb();
  const doc = await db.collection(COLLECTION_NAME).doc(id).get();
  if (!doc.exists) return null;
  return serializeDoc(doc);  // Convert Firestore doc to JS object
};

// Read - Find with Query
const findByUser = async (userId, options = {}) => {
  const db = getDb();
  let query = db.collection(COLLECTION_NAME).where('user', '==', userId);
  
  // Apply filters if provided
  if (options.category) {
    query = query.where('category', '==', options.category);
  }
  
  const snapshot = await query.get();
  return snapshot.docs.map(doc => serializeDoc(doc));
};

// Update
const updateById = async (id, updateData) => {
  const db = getDb();
  await db.collection(COLLECTION_NAME).doc(id).update(updateData);
  return await findById(id);  // Return updated document
};

// Delete
const deleteById = async (id) => {
  const db = getDb();
  await db.collection(COLLECTION_NAME).doc(id).delete();
  return true;
};

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ KEY MODELS EXPLAINED                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

USER MODEL (models/User.js)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Purpose: User account management & authentication

Key Methods:
  â€¢ createUser(userData)
    â””â”€â†’ Hash password with bcryptjs (8 salt rounds)
    â””â”€â†’ Stores in Firestore
    â””â”€â†’ Returns user object with generated ID

  â€¢ findByEmail(email, includePassword = false)
    â””â”€â†’ Firestore query: collection.where('email', '==', email)
    â””â”€â†’ includePassword: true for login, false for profile display
    â””â”€â†’ Strips password from response if false

  â€¢ findById(id, includePassword = false)
    â””â”€â†’ Direct document fetch: collection.doc(id).get()
    â””â”€â†’ Includes serialization of timestamps

  â€¢ matchPassword(enteredPassword, hashedPassword)
    â””â”€â†’ Async bcrypt comparison
    â””â”€â†’ Returns true/false (timing-safe)
    â””â”€â†’ Used during login verification

  â€¢ getSignedJwtToken(userId)
    â””â”€â†’ Creates JWT: { id: userId, iat: now, exp: now + 7days }
    â””â”€â†’ Signed with process.env.JWT_SECRET
    â””â”€â†’ 7 days expiration (configurable)

  â€¢ updateUser(id, updateData)
    â””â”€â†’ Partial update of user document
    â””â”€â†’ If password included, hashes it first
    â””â”€â†’ Returns updated user object

Security Considerations:
  âœ“ Passwords never returned to client
  âœ“ Passwords hashed before storage
  âœ“ Timing-safe password comparison (bcrypt)
  âœ“ JWT secret stored in env, not in code
  âœ“ Email field unique in Firestore (enforced via rules)

EXPENSE MODEL (models/Expense.js)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Purpose: Personal and group transaction tracking

Key Methods:
  â€¢ create(expenseData)
    â””â”€â†’ Creates expense document
    â””â”€â†’ Fields: amount, category, merchant, date, source
    â””â”€â†’ source: 'manual' or 'sms_auto' for auto-parsed

  â€¢ findByUser(userId, options = {})
    â””â”€â†’ Filters: startDate, endDate, category, limit
    â””â”€â†’ In-memory sorting (by date descending)
    â””â”€â†’ Handles Firestore index limitations

  â€¢ aggregateByCategory(userId, startDate, endDate)
    â””â”€â†’ Returns expense totals per category
    â””â”€â†’ Used for pie chart analytics
    â””â”€â†’ Calculates percentages

  â€¢ getDailyExpense(userId, startDate, endDate)
    â””â”€â†’ Groups expenses by date
    â””â”€â†’ Used for trend/line charts
    â””â”€â†’ Returns [{ date, amount, count }, ...]

Special Fields:
  â€¢ source: Tracks if expense is manual entry or auto-parsed from SMS
  â€¢ groupExpenseId: Links to GROUP_EXPENSES document (for splitwise)
  â€¢ smsId: References the SMS that generated this expense (audit trail)
  â€¢ confidence: Score from SMS parsing (0-1)
  â€¢ paymentMethod: cash, card, upi, bank_transfer

INCOME MODEL (models/Income.js)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Purpose: Income tracking by source and time period

Key Methods:
  â€¢ create(incomeData)
    â””â”€â†’ Creates income document
    â””â”€â†’ Fields: amount, source, month, year, date

  â€¢ findByUser(userId, options = {})
    â””â”€â†’ Filters: month, year
    â””â”€â†’ Returns in descending date order

  â€¢ getTotalForMonth(userId, month, year)
    â””â”€â†’ Quick aggregation for dashboard summary
    â””â”€â†’ Returns single number: total income

  â€¢ getTotalForRange(userId, startDate, endDate)
    â””â”€â†’ Calculates income for date range
    â””â”€â†’ Used in analytics comparisons

  â€¢ getDailyIncome(userId, startDate, endDate)
    â””â”€â†’ Groups income by day
    â””â”€â†’ Used for income trend charts

Income Sources:
  'pocket_money', 'salary', 'freelance', 'gift', 'scholarship', 'other'

GROUP MODEL (models/Group.js)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Purpose: Group creation and member management for bill splitting

Key Methods:
  â€¢ create(groupData)
    â””â”€â†’ Creates group document
    â””â”€â†’ Auto-generates 6-char invite code
    â””â”€â†’ Members array with userId and email
    â””â”€â†’ CreatedBy field tracks creator

  â€¢ generateInviteCode()
    â””â”€â†’ Random 6-char string: uppercase + numbers
    â””â”€â†’ Example: "A3B8Z2"
    â””â”€â†’ Used for joining without email

  â€¢ findByMember(userId)
    â””â”€â†’ Fetch all groups where user is member
    â””â”€â†’ Filters in-memory (Firestore array limitation)

  â€¢ findByInviteCode(code)
    â””â”€â†’ Lookup group by invite code
    â””â”€â†’ Used when joining a group

  â€¢ addMember(groupId, member)
    â””â”€â†’ Adds user to group members array
    â””â”€â†’ Checks for duplicates
    â””â”€â†’ Updates group.updatedAt

  â€¢ calculateBalances(groupId)
    â””â”€â†’ Complex calculation of who owes whom
    â””â”€â†’ Based on all group_expenses
    â””â”€â†’ Returns net balances

Group Structure:
  {
    name: "Bali Trip 2024",
    description: "Vacation expenses",
    members: [
      { userId: "user1", email: "john@example.com", joinedAt: ... },
      { userId: "user2", email: "jane@example.com", joinedAt: ... }
    ],
    inviteCode: "ABC123",
    createdBy: "user1",
    createdAt: timestamp
  }

KYC MODEL (models/KYC.js)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Purpose: Identity verification document and face matching data

Key Methods:
  â€¢ createOrGet(userId)
    â””â”€â†’ Gets existing KYC for user, or creates new one
    â””â”€â†’ Prevents duplicate KYC documents

  â€¢ findByUser(userId)
    â””â”€â†’ Lookup KYC document for verification check
    â””â”€â†’ Used throughout KYC flow

  â€¢ updateDocument(userId, documentType, filePath, ocrData)
    â””â”€â†’ Stores uploaded document information
    â””â”€â†’ ocrData: { rawText, confidence, extractedFields }

  â€¢ addVerificationHistory(userId, step, status, message)
    â””â”€â†’ Audit trail of verification steps
    â””â”€â†’ Helps debug failed verifications
    â””â”€â†’ Shows progression through KYC workflow

KYC Status Transitions:
  NOT_STARTED â†’ PENDING (after document upload) 
            â†’ VERIFIED (after all steps done)
            â†’ FAILED (if any step fails)

================================================================================
SERVICE LAYER - BUSINESS LOGIC & EXTERNAL INTEGRATIONS
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SMS PARSER SERVICE (services/smsParser.js)                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸŒŸ CRITICAL INNOVATION: Converts SMS into expense transactions

Initialization:
  const smsParser = new SmsParser();
  â””â”€â†’ Initializes Google Gemini client
  â””â”€â†’ Loads 17 bank identifiers
  â””â”€â†’ Compiles regex patterns

Bank Identifiers (17 major Indian banks):
  'SBIINB', 'HDFCBK', 'ICICIB', 'AXISBK', 'PNBSMS', 'KOTAKBK',
  'PAYTM', 'GPAY', 'PHONEPE', 'AMAZPAY', 'BHARPE', 'SBIPAY',
  'YESBNK', 'CITIBK', 'SCBANK', 'HSBC', 'IDBIBNK'

Key Methods:

isPaymentSms(sender):
  Input: SMS sender ID (e.g., "SBIINB", "PAYTM")
  Logic: Checks if sender matches known bank identifiers
  Output: boolean
  Purpose: Early filter to avoid parsing non-payment SMS

parseSms(smsText, sender):
  
  Input:
    smsText: Raw SMS message
    sender: SMS sender ID
  
  Process:
    1. Amount Extraction
       â””â”€â†’ Regex: /(?:Rs\.?|INR|â‚¹)\s*([0-9,]+\.?\d*)/i
       â””â”€â†’ Matches: "â‚¹500", "Rs.1000", "INR 250.50"
       â””â”€â†’ Strips commas and converts to float
    
    2. Transaction Type Detection
       â””â”€â†’ Debit pattern: debited|spent|paid|withdrawn|deducted|purchase
       â””â”€â†’ Credit pattern: credited|received|deposited|refund|cashback
       â””â”€â†’ Sets type to 'expense' or 'income'
    
    3. Merchant Extraction
       â””â”€â†’ Regex: /(?:at|to|from|merchant)\s+([A-Za-z0-9\s&.-]+?)/i
       â””â”€â†’ Example: "at Amazon.com" â†’ "Amazon.com"
       â””â”€â†’ Cleaned for display
    
    4. UPI ID Extraction
       â””â”€â†’ Regex: /(?:UPI|VPA|UPI ID):\s*([a-zA-Z0-9._-]+@[a-zA-Z]+)/i
       â””â”€â†’ Format: "user@paytm" or "user@phonepe"
       â””â”€â†’ For identifying transaction counterparty
    
    5. Reference Number
       â””â”€â†’ Regex: /(?:Ref\.?|Txn)\s*(?:No\.?|ID|#)?\s*:?\s*([A-Z0-9]+)/i
       â””â”€â†’ Example: "Ref No: SBI123456"
       â””â”€â†’ Unique identifier for transaction
    
    6. Gemini AI Processing (if amount found)
       â””â”€â†’ Calls Google Gemini API
       â””â”€â†’ Analyzes SMS for category
       â””â”€â†’ Returns: { category: 'food', confidence: 0.92 }
  
  Output:
    {
      type: 'expense',
      amount: 500,
      merchant: 'Amazon',
      category: 'shopping',
      upiId: 'user@paytm',
      refNo: 'SBI123456',
      confidence: 0.87,
      needsReview: false
    }
  
  Confidence Rules:
    â€¢ 0.85 - 1.0: Trusted (auto-save optional)
    â€¢ 0.70 - 0.85: Medium (requires review)
    â€¢ < 0.70: Low (rejected or needs manual entry)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OCR SERVICE (services/ocrService.js)                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Purpose: Extract text from KYC documents using Tesseract

Implementation:
  Uses Tesseract.js (JavaScript OCR library)
  â””â”€â†’ No external API calls needed
  â””â”€â†’ Works offline
  â””â”€â†’ Takes 2-5 seconds per image

Key Methods:

extractText(imagePath):
  Input: File path to document image
  Process:
    1. Load image using Tesseract
    2. Run OCR on image
    3. Extract text from document
    4. Calculate confidence (0-1)
  Output:
    {
      text: "UIDAI Document\nName: John Doe\nUID: 123456789012\nDOB: 01-01-1990",
      confidence: 0.94
    }

validateDocument(documentType, ocrText):
  Input: Document type and extracted text
  Process:
    â€¢ Aadhaar: Check for "UIDAI" and 12-digit number
    â€¢ PAN: Check for 10-char PAN format
    â€¢ Passport: Check passport indicators
    â€¢ DL: Validate with state codes
  Output: boolean (valid or not)

Example OCR Result:
  Input: Photo of Aadhaar card
  Output:
    {
      text: "UIDAI\nName: John Doe\nUID: 387654321098\nDOB: 15/10/1995",
      confidence: 0.96
    }
  Usage: Store first 500 chars in database, use for validation

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FACE SERVICE (services/faceService.js)                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Purpose: Compare faces between ID document and selfie

Technologies:
  â€¢ face-api.js: Face detection & recognition
  â€¢ Canvas: Image processing backend
  â€¢ Embedding-based comparison (cosine distance)

Key Methods:

validateFaceInImage(imagePath):
  Purpose: Check if image contains a valid face for KYC
  
  Checks:
    âœ“ Image exists and is readable
    âœ“ At least one face detected
    âœ“ Face occupies 30-70% of image
    âœ“ Face is frontal (pitch within -20Â° to +20Â°)
    âœ“ Lighting is adequate
    âœ“ No glasses or masks (configurable)
  
  Output:
    {
      hasFace: true,
      quality: 'good',
      details: {
        faceCount: 1,
        brightness: 0.8,
        angle: 'frontal'
      }
    }

compareFaces(docImagePath, selfiePath):
  Purpose: Compare face in ID document with selfie
  
  Process:
    1. Extract face embeddings from document image
       â””â”€â†’ 128-dimensional vector representation
    2. Extract face embeddings from selfie
       â””â”€â†’ Same 128-dimensional space
    3. Calculate cosine similarity
       â””â”€â†’ Distance between vectors
    4. Apply threshold:
       â””â”€â†’ Score >= 0.85: Faces match âœ“
       â””â”€â†’ Score < 0.85: Faces don't match âœ—
  
  Output:
    {
      isMatch: true,
      score: 0.92,
      details: {
        docFaceQuality: 'good',
        selfieFaceQuality: 'excellent',
        matchDetails: 'High confidence match'
      }
    }
  
  Liveness Detection (Production):
    â€¢ Challenge user to perform actions (blink, smile)
    â€¢ Detect movement in video
    â€¢ Check eyes are open and focused
    â€¢ Anti-spoofing checks (detects printed photos)

Tuning Parameters:
  â€¢ Threshold: 0.85 (adjust for false positive/negative rate)
  â€¢ Quality checks: Can be relaxed for accessibility
  â€¢ Liveness: Can be enabled/disabled based on security needs

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MFA SERVICE (services/mfaService.js)                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Purpose: Send OTP and verify multi-factor authentication

Key Methods:

generateOTP():
  â””â”€â†’ Uses otp-generator package
  â””â”€â†’ Generates 6-digit OTP
  â””â”€â†’ Example: "123456"
  â””â”€â†’ Validity: 10 minutes

sendOTP(email, otp):
  â””â”€â†’ Uses Nodemailer to send via SMTP
  â””â”€â†’ Email template: Professional, with branding
  â””â”€â†’ Subject: "Your Finzo KYC Verification Code"
  â””â”€â†’ Body: Large OTP display, 10-min expiry notice
  â””â”€â†’ Returns: true if sent successfully

verifyOTP(storedOTP, enteredOTP):
  â””â”€â†’ Compare submitted OTP with stored
  â””â”€â†’ Check if OTP not expired
  â””â”€â†’ Mark as used (prevent replay)
  â””â”€â†’ Returns: { valid: true/false, message: string }

SMTP Configuration:
  Host: smtp.gmail.com (or custom)
  Port: 587 (TLS)
  From: business@finzo.com
  Auth: Service account email & app password
  Rate limiting: Max 5 OTPs per 15 minutes

================================================================================
CONTROLLER LAYER - REQUEST HANDLING
================================================================================

Controller Pattern:

exports.methodName = async (req, res) => {
  try {
    // 1. Extract and validate input
    const { field1, field2 } = req.body;
    
    // 2. Call model/service methods
    const result = await Model.method(param);
    
    // 3. Return standardized response
    res.status(200).json({
      success: true,
      message: 'Operation successful',
      data: result
    });
    
  } catch (error) {
    // 4. Centralized error handling
    res.status(500).json({
      success: false,
      message: 'Error message',
      error: error.message
    });
  }
};

Response Format (Standardized):
  Success:
    {
      success: true,
      message: 'Optional message',
      data: { /* actual data */ }
    }
  
  Error:
    {
      success: false,
      message: 'Error description',
      error: 'Technical error details'
    }

Validation Strategy:
  â€¢ express-validator for schema validation
  â€¢ Custom validators for business logic
  â€¢ Firestore rules as backup validation
  â€¢ Sanitization of inputs

Example Controller - Create Expense:

exports.createExpense = async (req, res) => {
  try {
    const { amount, category, description, merchant, date } = req.body;
    
    // Validation
    if (!amount || amount <= 0) {
      return res.status(400).json({
        success: false,
        message: 'Please provide valid amount'
      });
    }
    
    if (!category || !EXPENSE_CATEGORIES.includes(category.toLowerCase())) {
      return res.status(400).json({
        success: false,
        message: 'Invalid category'
      });
    }
    
    // Create expense
    const expense = await Expense.create({
      user: req.user.id,
      amount,
      category: category.toLowerCase(),
      description,
      merchant,
      date: date ? new Date(date) : new Date(),
      source: 'manual'
    });
    
    res.status(201).json({
      success: true,
      message: 'Expense created successfully',
      data: expense
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Error creating expense',
      error: error.message
    });
  }
};

================================================================================
ROUTE CONFIGURATION
================================================================================

Routes are organized by feature:

auth.js - Authentication routes
  POST /api/auth/register
  POST /api/auth/login
  GET /api/auth/verify
  POST /api/auth/logout

expense.js - Expense management
  POST /api/expenses (+ protect middleware)
  GET /api/expenses
  GET /api/expenses/:id
  PUT /api/expenses/:id
  DELETE /api/expenses/:id

income.js - Income tracking
  POST /api/income
  GET /api/income
  GET /api/income/:id
  PUT /api/income/:id
  DELETE /api/income/:id

analytics.js - Financial insights
  GET /api/analytics/category (pie chart data)
  GET /api/analytics/summary (dashboard summary)
  GET /api/analytics/daily (trend data)
  GET /api/analytics/comparison (month comparison)

group.js - Group expense splitting
  POST /api/groups (create group)
  GET /api/groups (list user's groups)
  GET /api/groups/:id (group details + balances)
  POST /api/groups/:id/expenses (add group expense)
  POST /api/groups/:id/settle (settle debt)
  POST /api/groups/:code/join (join via invite code)

kyc.js - Identity verification
  GET /api/kyc/status
  POST /api/kyc/upload-document (+ multer)
  POST /api/kyc/upload-selfie (+ multer)
  POST /api/kyc/verify-mfa

sms.js - SMS transaction processing
  POST /api/sms/parse (parse SMS)
  GET /api/sms/list (list parsed transactions)
  POST /api/sms/confirm/:id (save as expense)
  POST /api/sms/reject/:id (discard)

Route Protection:
  Routes that modify data or access user data use protect middleware
  â””â”€â†’ Ensures request includes valid JWT token
  â””â”€â†’ req.user populated from token
  â””â”€â†’ Prevents unauthorized access

================================================================================
ERROR HANDLING & LOGGING
================================================================================

Logging Strategy:

Console Logs with Context Labels:
  [AuthMiddleware] Headers: {...}
  [KYC] Processing document: /uploads/kyc_12345.jpg
  [FaceMatch] Comparing images...
  [SmsParser] Parsed transaction: { amount: 500, ... }

Development Mode:
  â€¢ Detailed logs with full data
  â€¢ Morgan logging every HTTP request
  â€¢ Stack traces for debugging
  â€¢ Response body logging

Production Mode (Recommended):
  â€¢ Sensitive data filtered from logs
  â€¢ Centralized logging service (Winston, Bunyan)
  â€¢ Error tracking (Sentry)
  â€¢ Performance monitoring (New Relic)

Error Categories:

1. Validation Errors (400)
   â€¢ Invalid input format
   â€¢ Missing required fields
   â€¢ Out of range values

2. Authentication Errors (401)
   â€¢ No token provided
   â€¢ Invalid token
   â€¢ Token expired
   â€¢ User not found

3. Authorization Errors (403)
   â€¢ User doesn't own resource
   â€¢ Insufficient permissions
   â€¢ Account not verified

4. Not Found Errors (404)
   â€¢ Resource doesn't exist
   â€¢ User not found
   â€¢ Group not found

5. Server Errors (500)
   â€¢ Database connection error
   â€¢ External service failure
   â€¢ Unhandled exception

Error Recovery:

Database Failures:
  â€¢ Retry logic with exponential backoff
  â€¢ Graceful degradation
  â€¢ Fallback to MongoDB if Firestore fails

External API Failures:
  â€¢ Timeout handling (10 seconds)
  â€¢ Retry with circuit breaker
  â€¢ Graceful error messages to user

File Upload Failures:
  â€¢ Clean up temporary files
  â€¢ Return clear error message
  â€¢ Log file details for debugging

================================================================================
PERFORMANCE CONSIDERATIONS
================================================================================

Query Optimization:

Expensive Operations:
  âŒ Fetching all expenses, then filtering in memory
  âœ“ Push filters to Firestore query

  âŒ Getting user details in every request
  âœ“ Cache in request header or Redis

  âŒ Multiple sequential DB calls
  âœ“ Batch operations or load in parallel

Index Strategy:

Required Indexes:
  â€¢ users: email (for login)
  â€¢ expenses: (user, date) for date range queries
  â€¢ expenses: (user, category) for category filtering
  â€¢ income: (user, month, year) for monthly summaries
  â€¢ groups: inviteCode (for joining)
  â€¢ kyc: user (for KYC lookup)

Firestore Limitations:
  â€¢ Array queries not directly supported
    Solution: Filter in application code
  â€¢ Multiple inequality filters not allowed
    Solution: Query with one inequality, filter others in JS
  â€¢ No OR queries
    Solution: Multiple queries, then merge results

Caching Strategy:

Frontend Caching:
  â€¢ Analytics results cached for 5 minutes
  â€¢ User profile cached for session
  â€¢ Category list cached (rarely changes)

Backend Caching (Optional):
  â€¢ Redis for frequently accessed data
  â€¢ Cache expiration: 5-10 minutes
  â€¢ Invalidate on write

Request Optimization:
  â€¢ Compress responses with gzip
  â€¢ Pagination for large datasets
  â€¢ Return only needed fields (sparse queries)
  â€¢ Conditional requests with ETags

================================================================================
DEPLOYMENT CHECKLIST
================================================================================

Pre-deployment:
  âœ“ All environment variables set in .env
  âœ“ Firebase credentials configured
  âœ“ SMTP credentials for email working
  âœ“ Firestore indexes created
  âœ“ Security rules reviewed and set
  âœ“ File upload directory writable
  âœ“ API tested with Postman/Insomnia

Deployment:
  âœ“ npm install (no dev dependencies)
  âœ“ NODE_ENV=production npm start
  âœ“ Monitor startup logs
  âœ“ Verify database connectivity
  âœ“ Test API endpoints
  âœ“ Check CORS headers
  âœ“ Verify file uploads work

Post-deployment:
  âœ“ Monitor error logs
  âœ“ Check response times
  âœ“ Verify user registration flow
  âœ“ Test KYC document upload
  âœ“ Verify email notifications sending
  âœ“ Check database queries performance
  âœ“ Monitor file storage usage

Scaling Considerations:
  â€¢ Database: Firestore auto-scales
  â€¢ Backend: Stateless, can run multiple instances
  â€¢ Load balancer: Route traffic across instances
  â€¢ Cache layer: Add Redis for high-traffic
  â€¢ File storage: Migrate uploads to Google Cloud Storage
  â€¢ CDN: Serve static assets via CDN

================================================================================
TROUBLESHOOTING GUIDE
================================================================================

Issue: "Cannot find module 'firebase-admin'"
Fix: npm install || npm install firebase-admin

Issue: "FIREBASE_PROJECT_ID not set"
Fix: Create .env file with credentials
     or set environment variables in deployment platform

Issue: "Cannot connect to Firestore"
Fix: Verify firebase-service-account.json exists
     Check credentials are valid
     Verify network connectivity

Issue: "File upload failing"
Fix: Check /uploads directory exists and writable
     Check file size limit (50MB)
     Verify multer configuration

Issue: "JWT token verification failing"
Fix: Ensure JWT_SECRET is same across all instances
     Check token not expired
     Verify Authorization header format

Issue: "KYC verification slow"
Fix: Tesserat OCR takes 2-5 seconds (normal)
     Face matching takes ~2 seconds (normal)
     Check server CPU/memory usage
     Consider async job queue for large volumes

Issue: "SMS parsing inaccurate"
Fix: Check Gemini API key valid
     Verify bank sender in known list
     Adjust confidence threshold

================================================================================
SECURITY BEST PRACTICES
================================================================================

Secrets Management:
  âœ“ Never commit .env to git
  âœ“ Use environment variables in production
  âœ“ Rotate secrets regularly
  âœ“ Use secret management service (AWS Secrets Manager)

Data Protection:
  âœ“ Encrypt sensitive data at rest
  âœ“ Use HTTPS (enforce in production)
  âœ“ No sensitive data in logs
  âœ“ PII minimization

API Security:
  âœ“ Rate limiting (recommended)
  âœ“ Request validation & sanitization
  âœ“ CORS configured properly
  âœ“ No info leakage in errors

Database Security:
  âœ“ Firestore rules restrict access
  âœ“ No public anonymous access
  âœ“ User can only access own data
  âœ“ Admin operations protected

File Upload Security:
  âœ“ Validate file type
  âœ“ Scan for malware (optional)
  âœ“ Store outside web root (if possible)
  âœ“ Generate random filenames
  âœ“ Serve with Content-Disposition: attachment

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
End of Backend System Guide
For questions, refer to inline code comments and models/controllers
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
